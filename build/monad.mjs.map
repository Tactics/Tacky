{"version":3,"sources":["../src/monad/monads/optional/some.ts","../src/monad/monads/optional/none.ts","../src/monad/context/context-collection.ts","../src/monad/trace/trace-collection.ts","../src/monad/trace/trace-common.ts","../src/monad/monads/either/failure.ts","../src/monad/monads/either/success.ts"],"names":["Some","_Some","value","fn","newValue","None","_None","ContextCollection","_ContextCollection","key","context","newCollection","TraceCollection","_TraceCollection","trace","TraceCommon","_TraceCommon","message","time","Failure","_Failure","code","traces","contexts","previous","Success","_Success"],"mappings":"AAEO,IAAMA,EAAN,MAAMC,CAA+B,CAGlC,YAAYC,EAAU,CAC5B,KAAK,MAAQA,CACf,CAEA,OAAO,GAAMA,EAAmB,CAC9B,OAAO,IAAID,EAAKC,CAAK,CACvB,CAEA,KAAQC,EAA4C,CAClD,OAAOA,EAAG,KAAK,KAAK,CACtB,CAEA,QAAY,CACV,OAAO,KAAK,KACd,CAEA,IAAOA,EAAkC,CACvC,IAAMC,EAAWD,EAAG,KAAK,KAAK,EAC9B,OAAOF,EAAK,GAAGG,CAAQ,CACzB,CACF,ECtBO,IAAMC,EAAN,MAAMC,CAAgC,CAC3C,OAAO,IAAW,CAChB,OAAO,IAAIA,CACb,CAEA,KAAKH,EAA6C,CAChD,OAAO,IACT,CAEA,QAAgB,CACd,MAAM,IAAI,MAAM,mCAAmC,CACrD,CAEA,IAAOA,EAA+B,CACpC,OAAO,IACT,CACF,ECbO,IAAMI,EAAN,MAAMC,CAAsC,CAA5C,cACL,KAAQ,SAAuC,CAAC,EAEhD,OAAO,OAA2B,CAChC,OAAO,IAAIA,CACb,CAEA,IAAIC,EAAsC,CACxC,OAAO,KAAK,SAASA,CAAG,EAAIT,EAAK,GAAG,KAAK,SAASS,CAAG,CAAC,EAAIJ,EAAK,GAAG,CACpE,CAEA,IAAII,EAAaC,EAAqC,CACpD,IAAMC,EAAgB,IAAIH,EAC1B,OAAAG,EAAc,SAAW,CAAE,GAAG,KAAK,QAAS,EAC5CA,EAAc,SAASF,CAAG,EAAIC,EACvBC,CACT,CAEA,OAAOF,EAAgC,CACrC,IAAME,EAAgB,IAAIH,EAC1B,OAAAG,EAAc,SAAW,CAAE,GAAG,KAAK,QAAS,EAC5C,OAAOA,EAAc,SAASF,CAAG,EAC1BE,CACT,CAEA,EAAE,OAAO,QAAQ,GAAuB,CACtC,QAAWF,KAAO,KAAK,SACrB,MAAM,KAAK,SAASA,CAAG,CAE3B,CACF,EChCO,IAAMG,EAAN,MAAMC,CAAkC,CAGrC,aAAc,CAFtB,KAAU,OAAkB,CAAC,CAEN,CAEvB,OAAc,OAAyB,CACrC,OAAO,IAAIA,CACb,CAEO,IAAIC,EAA+B,CACxC,IAAMH,EAAgB,IAAIE,EAC1B,OAAAF,EAAc,OAAS,CAAC,GAAG,KAAK,OAAQG,CAAK,EACtCH,CACT,CAEA,EAAS,OAAO,QAAQ,GAAqB,CAC3C,QAAWG,KAAS,KAAK,OACvB,MAAMA,CAEV,CACF,ECrBO,IAAMC,EAAN,MAAMC,CAA6B,CAIhC,YAAYC,EAAiBC,EAAc,CACjD,KAAK,QAAUD,EACf,KAAK,KAAOC,CACd,CAEA,OAAc,KAAKD,EAAiBC,EAA2B,CAC7D,OAAO,IAAIF,EAAYC,EAASC,CAAI,CACtC,CAEO,MAAe,CACpB,OAAO,KAAK,OACd,CAEO,IAAa,CAClB,OAAO,KAAK,IACd,CACF,ECbO,IAAMC,EAAN,MAAMC,CAAwC,CAQ3C,YACNH,EACAI,EACAC,EACAC,EACAC,EACA,CACA,KAAK,QAAUP,EACf,KAAK,KAAO,UACZ,KAAK,KAAOI,EACZ,KAAK,OAASC,EACd,KAAK,SAAWC,EAChB,KAAK,SAAWC,CAClB,CAEA,OAAO,MACLP,EACAI,EACAG,EACAV,EACAQ,EACAC,EACS,CAET,OAAAD,EAASA,GAAUV,EAAgB,MAAM,EACrCE,EACFQ,EAAO,IAAIR,CAAK,EAGhBQ,EAAO,IAAIP,EAAY,KAAKE,EAAS,KAAK,IAAI,CAAC,CAAC,EAGlDM,EAAWA,GAAYhB,EAAkB,MAAM,EACxC,IAAIa,EACTH,EACAI,EACAC,EACAC,EACAC,GAAsB,IACxB,CACF,CAEA,KAAKrB,EAAoD,CACvD,OAAO,IACT,CAEA,IAAIA,EAA4C,CAC9C,OAAO,IACT,CAEA,KAAKD,EAA6B,CAChC,OAAO,IACT,CAEA,QAAgB,CACd,MAAM,IAAI,MAAM,uCAAuC,CACzD,CAEA,WAAoB,CAClB,OAAO,KAAK,MACd,CAEA,UAAUY,EAA6B,CACrC,YAAK,OAAO,IAAIA,CAAK,EACd,IACT,CAEA,YAAYL,EAAaC,EAAiC,CACxD,YAAK,SAAS,IAAID,EAAKC,CAAO,EACvB,IACT,CAEA,WAAWD,EAAsC,CAC/C,OAAO,KAAK,SAAS,IAAIA,CAAG,CAC9B,CAEA,aAAwB,CACtB,OAAO,KAAK,QACd,CAEA,aAAaA,EAA4B,CACvC,YAAK,SAAS,OAAOA,CAAG,EACjB,IACT,CACF,EC7FO,IAAMgB,EAAN,MAAMC,CAAgC,CAKnC,YAAYxB,EAAUoB,EAAgBC,EAAoB,CAChE,KAAK,MAAQrB,EACb,KAAK,OAASoB,EACd,KAAK,SAAWC,CAClB,CAEA,OAAO,GAAGrB,EAAYoB,EAAwBC,EAA4B,CACxE,OAAO,IAAIG,EACTxB,EACAoB,GAAUV,EAAgB,MAAM,EAChCW,GAAYhB,EAAkB,MAAM,CACtC,CACF,CAEA,KAAKJ,EAAwC,CAC3C,OAAOA,EAAG,KAAK,KAAK,CACtB,CAEA,KAAKD,EAAuB,CAC1B,OAAO,IAAIwB,EAAQxB,EAAO,KAAK,OAAQ,KAAK,QAAQ,CACtD,CAEA,IAAIC,EAAoC,CACtC,OAAO,IAAIuB,EAAQvB,EAAG,KAAK,KAAK,EAAG,KAAK,OAAQ,KAAK,QAAQ,CAC/D,CAEA,QAAY,CACV,OAAO,KAAK,KACd,CAEA,WAAoB,CAClB,OAAO,KAAK,MACd,CAEA,UAAUW,EAAyB,CACjC,YAAK,OAAO,IAAIA,CAAK,EACd,IACT,CAEA,YAAYL,EAAaC,EAA6B,CACpD,YAAK,SAAS,IAAID,EAAKC,CAAO,EACvB,IACT,CAEA,WAAWD,EAAsC,CAC/C,OAAO,KAAK,SAAS,IAAIA,CAAG,CAC9B,CAEA,aAAwB,CACtB,OAAO,KAAK,QACd,CAEA,aAAaA,EAAwB,CACnC,YAAK,SAAS,OAAOA,CAAG,EACjB,IACT,CACF","sourcesContent":["import { Optional } from \"@/monad/optional\";\n\nexport class Some<T> implements Optional<T> {\n  private readonly value: T;\n\n  private constructor(value: T) {\n    this.value = value;\n  }\n\n  static of<T>(value: T): Some<T> {\n    return new Some(value);\n  }\n\n  bind<U>(fn: (value: T) => Optional<U>): Optional<U> {\n    return fn(this.value);\n  }\n\n  unwrap(): T {\n    return this.value;\n  }\n\n  map<U>(fn: (value: T) => U): Optional<U> {\n    const newValue = fn(this.value);\n    return Some.of(newValue);\n  }\n}\n","// Define the None class implementing the Optional interface\nimport { Optional } from \"@/monad/optional\";\n\nexport class None implements Optional<never> {\n  static of(): None {\n    return new None();\n  }\n\n  bind(fn: (value: never) => Optional<never>): None {\n    return this;\n  }\n\n  unwrap(): never {\n    throw new Error(\"Value of None cannot be unwrapped\");\n  }\n\n  map<U>(fn: (value: never) => U): None {\n    return this;\n  }\n}\n","import { Contexts } from \"@/monad/context/contexts\";\nimport { Context } from \"@/monad/context/context\";\nimport { OptionalResult } from \"@/monad/result\";\nimport { Some } from \"@/monad/monads/optional/some\";\nimport { None } from \"@/monad/monads/optional/none\";\n\nexport class ContextCollection implements Contexts {\n  private contexts: { [key: string]: Context } = {};\n\n  static empty(): ContextCollection {\n    return new ContextCollection();\n  }\n\n  get(key: string): OptionalResult<Context> {\n    return this.contexts[key] ? Some.of(this.contexts[key]) : None.of();\n  }\n\n  add(key: string, context: Context): ContextCollection {\n    const newCollection = new ContextCollection();\n    newCollection.contexts = { ...this.contexts };\n    newCollection.contexts[key] = context;\n    return newCollection;\n  }\n\n  remove(key: string): ContextCollection {\n    const newCollection = new ContextCollection();\n    newCollection.contexts = { ...this.contexts };\n    delete newCollection.contexts[key];\n    return newCollection;\n  }\n\n  *[Symbol.iterator](): Iterator<Context> {\n    for (const key in this.contexts) {\n      yield this.contexts[key];\n    }\n  }\n}\n","// Implement the TraceCollection class\nimport { Traces } from \"@/monad/trace/traces\";\nimport { Trace } from \"@/monad/trace/trace\";\n\nexport class TraceCollection implements Traces {\n  protected traces: Trace[] = [];\n\n  private constructor() {}\n\n  public static empty(): TraceCollection {\n    return new TraceCollection();\n  }\n\n  public add(trace: Trace): TraceCollection {\n    const newCollection = new TraceCollection();\n    newCollection.traces = [...this.traces, trace];\n    return newCollection;\n  }\n\n  public *[Symbol.iterator](): Iterator<Trace> {\n    for (const trace of this.traces) {\n      yield trace;\n    }\n  }\n}\n","// Implement the TraceCommon class\nimport { Trace } from \"@/monad/trace/trace\";\n\nexport class TraceCommon implements Trace {\n  private readonly message: string;\n  private readonly time: number;\n\n  private constructor(message: string, time: number) {\n    this.message = message;\n    this.time = time;\n  }\n\n  public static from(message: string, time: number): TraceCommon {\n    return new TraceCommon(message, time);\n  }\n\n  public read(): string {\n    return this.message;\n  }\n\n  public at(): number {\n    return this.time;\n  }\n}\n","import { Either } from \"@/monad/either\";\nimport { OptionalResult, Result } from \"@/monad/result\";\nimport { Traces } from \"@/monad/trace/traces\";\nimport { Trace } from \"@/monad/trace/trace\";\nimport { Contexts } from \"@/monad/context/contexts\";\nimport { Context } from \"@/monad/context/context\";\nimport { TraceCollection } from \"@/monad/trace/trace-collection\";\nimport { TraceCommon } from \"@/monad/trace/trace-common\";\nimport { ContextCollection } from \"@/monad/context/context-collection\";\n\nexport class Failure implements Either<never>, Error {\n  private readonly traces: Traces;\n  private readonly contexts: Contexts;\n  message: string;\n  code: string;\n  name: string;\n  previous: Error | null;\n\n  private constructor(\n    message: string,\n    code: string,\n    traces: Traces,\n    contexts: Contexts,\n    previous: Error | null,\n  ) {\n    this.message = message;\n    this.name = \"Failure\";\n    this.code = code;\n    this.traces = traces;\n    this.contexts = contexts;\n    this.previous = previous;\n  }\n\n  static dueTo(\n    message: string,\n    code: string,\n    previous?: Error | null,\n    trace?: Trace | null,\n    traces?: Traces | null,\n    contexts?: Contexts | null,\n  ): Failure {\n    // Add Failure traces as last item.\n    traces = traces ?? TraceCollection.empty();\n    if (trace) {\n      traces.add(trace);\n    } else {\n      // Fallback to a common trace of the message when no specific trace was provided.\n      traces.add(TraceCommon.from(message, Date.now()));\n    }\n\n    contexts = contexts ?? ContextCollection.empty();\n    return new Failure(\n      message,\n      code,\n      traces,\n      contexts,\n      previous ? previous : null,\n    );\n  }\n\n  bind(fn: (value: never) => Result<never>): Result<never> {\n    return this;\n  }\n\n  map(fn: (value: never) => never): Result<never> {\n    return this;\n  }\n\n  lift(value: never): Result<never> {\n    return this;\n  }\n\n  unwrap(): never {\n    throw new Error(\"Value of Failure can not be unwrapped\");\n  }\n\n  getTraces(): Traces {\n    return this.traces;\n  }\n\n  withTrace(trace: Trace): Result<never> {\n    this.traces.add(trace);\n    return this;\n  }\n\n  withContext(key: string, context: Context): Result<never> {\n    this.contexts.add(key, context);\n    return this;\n  }\n\n  getContext(key: string): OptionalResult<Context> {\n    return this.contexts.get(key);\n  }\n\n  getContexts(): Contexts {\n    return this.contexts;\n  }\n\n  clearContext(key: string): Result<never> {\n    this.contexts.remove(key);\n    return this;\n  }\n}\n","import { Either } from \"@/monad/either\";\nimport { OptionalResult, Result } from \"@/monad/result\";\nimport { Contexts } from \"@/monad/context/contexts\";\nimport { Traces } from \"@/monad/trace/traces\";\nimport { Trace } from \"@/monad/trace/trace\";\nimport { Context } from \"@/monad/context/context\";\nimport { TraceCollection } from \"@/monad/trace/trace-collection\";\nimport { ContextCollection } from \"@/monad/context/context-collection\";\n\nexport class Success<T> implements Either<T> {\n  private readonly value: T;\n  private readonly traces: Traces;\n  private readonly contexts: Contexts;\n\n  private constructor(value: T, traces: Traces, contexts: Contexts) {\n    this.value = value;\n    this.traces = traces;\n    this.contexts = contexts;\n  }\n\n  static of(value: any, traces?: Traces | null, contexts?: Contexts | null) {\n    return new Success(\n      value,\n      traces ?? TraceCollection.empty(),\n      contexts ?? ContextCollection.empty(),\n    );\n  }\n\n  bind(fn: (value: T) => Result<T>): Result<T> {\n    return fn(this.value);\n  }\n\n  lift(value: any): Result<T> {\n    return new Success(value, this.traces, this.contexts);\n  }\n\n  map(fn: (value: any) => any): Result<T> {\n    return new Success(fn(this.value), this.traces, this.contexts);\n  }\n\n  unwrap(): T {\n    return this.value;\n  }\n\n  getTraces(): Traces {\n    return this.traces;\n  }\n\n  withTrace(trace: Trace): Result<T> {\n    this.traces.add(trace);\n    return this;\n  }\n\n  withContext(key: string, context: Context): Result<T> {\n    this.contexts.add(key, context);\n    return this;\n  }\n\n  getContext(key: string): OptionalResult<Context> {\n    return this.contexts.get(key);\n  }\n\n  getContexts(): Contexts {\n    return this.contexts;\n  }\n\n  clearContext(key: string): Result<T> {\n    this.contexts.remove(key);\n    return this;\n  }\n}\n"]}